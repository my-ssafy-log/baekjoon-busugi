# 1486 장훈이의 높은 선반

[링크](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?contestProbId=AV2b7Yf6ABcBBASw&solveclubId=AZewY0EKsb3HBIN_&problemBoxTitle=%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98+Track%28%EB%82%9C%EC%9D%B4%EB%8F%84+%EC%83%81%29&problemBoxCnt=3&probBoxId=AZewY0EKsb7HBIN_)

## 문제 해설

이 문제는 사람들의 수 N과 선반 높이 B가 주어지고  
N명의 사람들의 키가 주어질 때  
N명의 사람들의 키의 여러 합들 중 선반 높이보다 큰 최소 합과 선반 높이의 차이값을 구하는 문제이다.

예를 들어
```
5 16  
1 3 3 5 6
```
사람의 수: `5`  
선반 높이: `16`  
각각의 사람들의 키 높이: `1, 3, 3, 5, 6`  
이라고 할 때
선반 높이보다 크면서 최솟값이 되는 합은 `3 + 3 + 5 + 6`으로 `17`로  
`16`과의 차는 `1`이므로 출력은 `1`이 된다.

## 코드 해설
이 문제는 먼저 C++로 푼 문제와, 파이썬의 숫자 범위의 한계는 없다는 점을 이용해 비트마스킹의 아이디어를 착안해 푼 문제,  
이렇게 2문제가 있다.

### C++ 코드
[C++ 코드](./code.cpp)  
처음 이 문제를 풀 때는 C++로 완전탐색으로 풀었다.  
먼저 사람들을 하나씩 완전탐색을 할 재귀함수 `f(int *arr, int cur_i, int sum)`를 이용하여 풀었다.  
f 함수에서 `cur_i`는 합을 하는 인덱스를 나타내는데, 사람들의 합을 계산할 때는 순서를 보지 않는 조합이기 때문에,  
f 함수 내에 `for` 문의 i는 `cur_i + 1`부터 시작한다.  
그리고 `cur_i`의 다음 인덱스가 f 함수에 넘어가기에 `visited` 배열 또한 필요가 없었다.  

main 함수에서도 f 함수에 넘기는 `cur_i` 값이 반복문의 매 실행마다 다 다르기에 인덱스가 겹쳐 중복될 일이 더더욱 없기에,  
이런 조합 문제는 `visited`를 필요로 하지 않는다.

f 함수의 종료 조건은 for 문을 다 돌았거나,  
f 함수의 현재까지 재귀한 함수들의 `cur_i`가 가리키는 사람들의 키들의 합을 나타내는 `sum`이  
선반 높이 **B보다 크거나 같으면** 종료가 된다.  
이때 **B보다 크거나 같으면**이라는 조건에는 `min_v`에 `sum`과 `min_v`를 비교해 최소 값을 갱신하는데,  
당연히 `sum`은 선반 높이를 넘기 때문에 `min_v`에 갱신되는 최소 값 또한 선반 높이보다 크면서 제일 작은 값이 갱신된다.

### Python 코드
[Python 코드](./code.py)  
비트마스킹과 DP를 이용해 푸는 방식이다.  
비트마스킹에 해당하는 변수 `dp`는 `0b00...0001`인 1로 초기화를 한다.
그리고 입력받은 사람들의 키를 하나씩 순회하면서 `dp |= dp << v`를 수행하는데 이 식의 의미는 다음과 예시로 의미를 알 수가 있다.

먼저 `dp`는 `for`문으로 사람들의 키를 하나씩 순회할 때 현재 인덱스를 `i`라고 한다면 `i`까지의 사람들의 키를 조합했을 때 나올 수 있는 합들을 비트로써 가리키는 변수라고 생각하면 된다.  
쉽게 사람들의 키 `1 3 3 5 6`를 예시로 살펴보면
1. `i`가 0일 때 해당 인덱스의 값은 1이므로 `dp |= dp << 1`, `0b01(dp) |= 0b010` 이므로 dp는 `0b011`가 된다.
2. `i`가 1일 때 해당하는 값은 3이므로 `dp |= dp << 3`, `0b011(dp) |= 0b011000`이므로 dp는 `0b011011`가 된다.  
    이때 비트는 왼쪽 비트를 시작으로 왼쪽으로 갈 수록 0, 1, 2, 3, ... 이런 값들을 가리킨다고 생각하면 되는데,  
    이 값들은 현재 `i` 인덱스까지의 숫자들로 조합해 만들 수 있는 합들을 2진수로 1로 가리킨다.  
    1과 3으로 만들 수 있는 합은 0(하나도 더하지 않았을 때), 1, 3, 4(1+3), 이렇게 총 4개인데,  
    `dp`를 보면 `0b011011`롤 왼쪽부터 0번, 1번, 3번, 4번 비트가 1인 것을 확인할 수 있다.
3. `i`가 2일 때 값은 3, `dp |= dp << 3`, `0b011011(dp) |= 0b011011000`, dp는 `0b011011011`  
    1, 3, 3으로 가능한 합: 0, 1, 3, 4, 6, 7
4. `i`가 3일 때 값은 5, `0b011011011(dp) |= 0b01101101100000`, dp는 `0b01101111111011`
    1, 3, 3, 5로 가능한 합: 0, 1, 3, 4, 5, 6, 7, 8, 9, 11, 12
5. `i`가 4일 때 값은 6, `0b01101111111011(dp) |= 0b01101111111011000000`, dp는 `0b01101111111111111011`
    1, 3, 3, 5, 6으로 가능한 합: 0, 1, 3, 4(3+1), 5, 6, 7(6+1), 8(5+3), 9(6+3), 10(6+3+1), 11(6+5), 12(6+5+1), 13(6+3+3+1), 14(6+5+3), 15(6+5+3+1), 17(6+5+3+3), 18(6+5+3+3+1)

이것이 가능한 이유는 `dp`의 각각의 비트는 각각 0, 1, 2, 3, ...으로 가리키는 값이 다 다르며,  
`i`번째 인덱스의 값을 `dp`에 더할 때 먼저 초기 값 `0b01`을 `<<`로 쉬프트로써 값을 더하면서, 그 값을 `|` 비트 `or` 연산자로 합치기 때문에,  
기존에 있던 합들은 계속해서 왼쪽으로 더해지면서도 동시에 `i`번째 값이 갱신이 가능해진다.  

그 후, b부터 `dp`로 만들어진 비트 길이 만큼 `i`에 값을 차례대로 넣으며 for문을 돌면서,  
dp를 `i`만큼 오른쪽으로 당겨서 `& 1`로 만약에 그 비트가 1이면 그 값, 즉, 그 합이 만들어진 합 중 b와 가장 가까운 합이라는 의미기에  
`min_v`에 값을 넣고 반복문을 벗어난다.  
그 후에 `min_v`와 `b`와의 차이값을 출력한다.