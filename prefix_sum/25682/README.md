# 25682 체스판 다시 칠하기 2

[링크](https://www.acmicpc.net/problem/25682)

## 문제 해설

이 문제는 검정색(Black)과 하얀색(White) 정사각형이 랜덤하게 배치돼 있는 N x M 크기의 보드에서 K x K 크기의 체스판을 만들기 위해서 자른다고 할 때,  
체스판처럼 만들기 위해 색이 반복되는 패턴처럼 보이도록 색칠을 하는 횟수가 최소가 되도록 자른다고 할 때 그 색칠 횟수의 최소값을 구하는 문제이다.

이 문제는 [체스판 다시 칠하기](https://www.acmicpc.net/problem/1018)처럼 범위가 50이하로 작지 않기 때문에 직관적으로  
"체스판을 왼쪽 상단부터, 오른쪽 하당까지 2중 for문으로 돌면서 그 for문 안에 K x K 만큼 돌기 위한 2중 for문을 둬서 4중 for문으로 풀 수 있겠구나"  
식으로 풀 수가 없다.  

이 문제에서 N과 M의 범위는 1~2,000이고, K의 범위도 1~min(N, M) 이기 때문에
만약 N, M이 2000, K가 1000이라고 하고 위처럼 직관적으로 푼다고 하면  
대략 (N-K) x (M-K) x K가 되고, 1000의 3제곱, 즉 10억번 돌기 때문에 10초가 걸리게 된다.  
이 문제는 1초라는 시간복잡도가 존재하기에 더 효율적인 방식으로 풀어야 한다.

## 코드 해설

[코드](./code.py)  

먼저 생각한 건, 이 N x M의 2차원 배열이 있고, **왼쪽 상단에 위치한 첫번째 요소**(이하 첫번째 요소)를 시작으로 해서 **오른쪽 하단 요소**(이하 마지막 요소)까지 검사를 진행하는 방식으로 풀어보려고 했다.  
이때 검사를 진행할 때 Black과 White를 반복하여 같은지 검사하고 같지 않다면 누적합에 값을 더하는 느낌으로 구현해보려고 했다.  
그리고 체스판 한줄처럼 색상을 반복하기 위해 이전 색상을 기억하는 변수(이하 플래그)를 `b_start_flag`로 선언했다.  
초기값을 Black으로 해서 반복하는 색상을 저장하겠다는 의미로 해당 플래그의 이름을 b_start라고 지었다.

누적합을 진행할 `black_presum`과 `white_presum`은 다음을 나타낸다.  
- `black_presum`: "첫번째 요소는 Black이다"라고 가정하고 검사를 진행할 때, 즉, 플래그의 색상을 그대로 따라가는데,  
    플래그와 맞지 않다면 2차원 배열 누적합 공식을 이용하여 그 위치의 누적합을 구한 뒤 1을 더해 해당 위치에 놓고,  
    플래그와 일치한다면 2차원 배열 누적합 공식을 이용하여 그 위치의 누적합만 구한 뒤 그 합만 해당 위치에 놓는다.
- `white_presum`: "첫번째 요소는 White이다"라고 가정하고 검사를 진행한다.  
    `black_presum`과 비슷하지만 첫번째 요소를 White로 두고 검사를 진행하기에 플래그를 반대로 따라가고 누적합을 구하는 공식 또한 위와 같다.

그리고 2차원 배열 누적합에서 K x K 크기의 구간합을 구하는 것 또한 2차원 배열의 구간합 구하는 공식을 사용하여  
N x M 크기의 누적합 배열에서 (N - K) x (M - K) 만큼 2중 for문을 돌아 가장 작은 K x K의 구간합을 구하는 방식으로 최소 값을 찾았다.  
이때 `black_presum`과 `white_presum` 누적합의 각각의 구간합을 구한 뒤, 그 둘 중 가장 작은 값을 최소값 변수와 작은지 비교해 최소값을 찾는 방식으로 최소값을 찾았다.

N과 M을 최대값인 2,000으로 두고 K를 1로 두었을 때 시간복잡도를 보면
첫번재 2중 for문에서 2,000x2,000으로 4백만,  
두번째 2중 for문에서 2,000x2,000으로 4백만,  
대략 1,000만에 못 미치기에 0.1초도 안걸려 시간복잡도 제약조건에 맞힐 수 있었다.


번외로 체스판처럼 색상 반복을 하는 플래그의 색상을 정하는 방식은 아래 생각을 참고로 구현하였다.  
- i, j의 합이 짝수라면 Black, 홀수라면 White
