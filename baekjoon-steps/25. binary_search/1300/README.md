# 1300 K번째 수

[링크](https://www.acmicpc.net/problem/1300)

## 문제 해설
1-indexed인 N x N의 이차원 배열 A의 행이 i, 열이 j라고 하고,  
$A[i][j] = i \times j$ 라고 할 때 이 수들을 1-indexed $N \times N$ 사이즈의 일차원 배열 B에 넣고 오람차순으로 정렬했을 때, K번째 수, 즉, $B[K]$ 값을 구하는 문제이다.

## 코드 해설
[참고](https://kbw1101.tistory.com/29)  
풀이 방법은 위 블로그를 참고해 풀 수 있었다.  
간단하게 정리하자면  
$5 \times 5$ 배열이 아래처럼 있다고 하고,
```
    1  2  3  4  5

1   1  2  3  4  5
2   2  4  6  8 10
3   3  6  9 12 15
4   4  8 12 16 20
5   5 10 15 20 25
```
11번째 수를 구한다고 했을 때,
각각의 행에 대해 11보다 작거나 같은 수들의 개수를 구한다.  
행 하나에서 개수를 구하는 식은 $min(K / i, N)$ 으로 구할 수 있는다.  
i의 행은 현재 i의 배수들로 이루어져 있는데 K를 i로 나눈 몫이 곧 K보다 같거나 작은 숫자들의 개수가 되기 때문에 행 하나에 대해 O(1)로 개수를 구할 수 있다.  

임의의 m에 대해 나온 이 개수가 만약 11보다 작다면 11번째 값은 K보다 큰 값이고,  
11보다 크다면 m가 11번째 값이거나 11번째 값보다 큰 값일 수 있는 것이다.  
이 m을 이분탐색의 mid로 두고 탐색을 하여 풀 수 있었다.
```python
mid = (start + end) // 2
lte_num = get_lte_num(mid)
if lte_num >= K:
    end = mid
    min_num = min(min_num, end)
elif lte_num < K:
    start = mid + 1
```
lte_num이 K보다 크거나 같을 때 mid값은 K번째 값이거나 큰 값일 수 있는데, 여기서 `K번째 값`이 `K번째 값보다 큰 값`보다 항상 작으므로 min_num에 최솟값으로 매번 갱신을 해줘 구할 수 있었다.