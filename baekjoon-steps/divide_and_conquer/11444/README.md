# 11444 피보나치 수 6

[링크](https://www.acmicpc.net/problem/11444)

## 문제 해설

이 문제는 N번째 피보나치 수를 구하는 문제인데 N의 범위가 1부터 100경일 때의 조건이 있는 문제이다.  
100경을 일일이 하나씩 돌면, 당연히 1억번 도는데 1초가 걸리니깐 100억초(대략 317년)가 걸린다.  

하지만, 이 N번쨰 값을 구할 때 N/2번째 값과 N/2번째 값을 이용하여 N번째 값을 구할 수 있는 방법을 찾는다면 log2(N), 즉, 100경은 2^60이니깐 최대 60번만 돌아도 100경번째의 값을 구할 수 있다.

## 코드 해설

[코드](./code.py)

이 문제를 풀기 직전에 행렬 제곱 문제를 풀었었는데, 이 행렬 제곱 문제에서 힌트를 우연히 n번 제곱했을 때 피보나치 수를 나타낼 수 있는 행렬을 찾았다.
```
[1 1
 1 0]
```
이 행렬을 1번 제곱하면, 즉, 제곱을 하면 아래같이 값이 나오는데
```
[2 1
 1 1]
```
2번 제곱하면
```
[3 2
 2 1]
```
3번 제곱하면  
```
[5 3
 3 2]
```
4번
```
[8 5
 5 3]
```
이렇게 피보나치 수들로만 이루어진 행렬이 나온다.  
이때 (1, 1)에 위치한 값이 이 n번 제곱했을 때의 피보나치 수가 되는 것이다.

행렬은 결합법칙이 가능하다.  
행렬 A, B, C가 있을 때 `(A * B) * C = A * (B * C)` 가 가능하다.  
이 말은 곱하기의 순서에 제한이 없고, 제곱을 한다고 했을 때 차례대로 할 필요가 없다는 의미이다.  
이 말은 행렬 A의 n 제곱은 `A^n = A^(n/2) * A^(n/2)` 이렇게 A의 2분의 n제곱으로 분할할 수 있다는 의미인데, 위에서 말한 log2(N) 구현이 가능해지는 것이다...!

이 문제를 해결하기 위해서 정의한 함수는 `multiply_2x2_matrix`과 `f`이다.  
`f`는 인자 수행할 제곱 횟수를 의미하는 N을 받아, N을 n//2로 분할하여 다시 계산하는 제귀함수이다.  
`multiply_2x2_matrix`는 2x2의 행렬 A, B를 받아 두 행렬을 곱한 새로운 2x2 행렬을 반환하는 함수이다.  
또한 함수 `f`에서 N을 분할하기에, N/2는 2번, N/4는 4번, ... N/(2M)^2(M은 재귀 깊이) 은 (2M)^2으로 기하급수적으로 늘어나므로, 겹치는 값들은 `memo` 딕셔너리를 이용하여 메모이제이션을 해준다.