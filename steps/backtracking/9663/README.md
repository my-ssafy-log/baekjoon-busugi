# 9663 N-Queen

[링크](https://www.acmicpc.net/problem/9663)

## 문제 해설

N-Qeen 문제는 **N x N 체스판**에 **N개의 퀸**을 **서로 공격하지 않는 위치**에 놓는 **경우의 수**를 구하는 문제다.  
체스에서 퀸은 가로, 세로, 대각선 1자로 이동한다.

아래의 예시는 **공격하는 예시**다.  
```
대각선 공격
- - Q
- - -
Q - -
가로 공격
Q - Q
- - -
- - -
세로 공격
Q - -
- - -
Q - -
```

아래는 **공격하지 않는 예시**다.
```
Q - -
- - Q
- - -
```

N이 4라면 퀸을 놓는 경우의 수는 2개로 아래의 체스판과 같다.

```
- Q - - 
- - - Q
Q - - - 
- - Q -
```

```
- - Q - 
Q - - -
- - - Q 
- Q - -
```
때문에 **N이 4라면 출력되는 답은 2가 돼야 한다.**

## 코드 해설

이 문제는 체스판의 행 별로 재귀를 돌면서 특정 열에 퀸을 놓을 수 있는지 탐색하는 **완전 탐색** 문제이면서  
특정 행에 퀸을 놓을 자리가 존재하지 않으면 더 이상 그 행 밑으로 내려가지 않는 **백트래킹** 문제이기도 하다.

먼저 전체 코드는 [code.cpp](./code.cpp)에 나와있다.

### 세팅

먼저 7 ~ 10번째 줄에서 퀸의 위치를 나타내는 `pos_type` 타입과, 체스판의 크기와 퀸의 개수를 나타내는 `n`, 경우의 수를 나타낼 `cnt`와,  
각 행 별 퀸의 위치값을 담는 `vector<pos_type>`을 선언하고 있다.

여기서 `pos_type`의 `pair`는 각각 **행**과 **열**을 나타낸다.

### main함수
`main`함수에서는 `n`을 입력 받아 **0**번 행을 기준으로 `for`문을 돌려서 **(0, 0)** ~ **(0, n-1)** 위치값을 벡터 `pos_v`에 넣고 `f` 함수를 돌리고 벡터 `pos_v`에서 제거하는 작업을 하고 있다.

f함수의 구현체는 다음과 같다.
### f함수
`f`함수는 재귀함수로 밭는 인자는 `int line`이다.
`f`함수가 `line+1`을 자기자신한테 넘기며 재귀를 하고 `line`이 `n`까지 도달했을 때 비로소 체스판이 완성이 되었다는 의미가 되고,  
경우의수를 하나 더한다는 의미가 되기 때문에
```c++
if (line == n) {
    cnt++;
    return;
}
```
이렇게 종료 조건과 함께 경우의 수를 더하는 코드가 있다.

제일 중요한 중심 코드는 `f`함수의 `for(1)`(`for(1)`이라고 지칭하겠다)문이다.  
이 `for(1)`문은 `main`함수의 `for`문과 흡사하지만 이 `for(1)`문 안에는
```c++
for (pos_type pos : pos_v) {
    if (
        pos.second == column ||
        abs(pos.first - line) == abs(pos.second - column)
    ) {
        is_valid = false;
    }
}
```
이렇게 또다른 `for(2)`문(`for(2)` 지칭하겠다)으로 어떤 검사를 수행하는 코드가 있다.  


`f`함수의 `for(1)`문도 `main`과 비슷하다.  
현재 `f`함수의 인자에 있는 `line` 행에 `column`을 돌며 `(line, 0)` ~ `(line, n-1)` 위치값을 벡터 `pos_v`에 저장한다.

이 `for(2)`는 벡터 `pos_v`에 위치값을 추가하기 전에 벡터 `pos_v`에 저장돼 있는 위치값을 하나씩 꺼내서  
`for(1)`문으로 변하는 `column`값에 따라 `(line, column)`이 하나씩 꺼낸 위치값에 공격받는지 검사해서 공격을 받는다면 `true`로 초기화 된 `is_valid`에 `false`값을 넣는 코드이다.  

공격받는지 확인하는 조건은 아래와 같다.
- 열을 나타내는 `.second`와 현재 `column`이 같거나 (세로로 겹치는가)
- 행을 나타내는 `.first`에 현재 `line`을 뺀 절대값이 `.second`에 현재 `column`을 뺀 절대값이 같다. (대각선으로 겹치는가)

가로 확인은 재귀함수 `f`를 실행할 때 `line`을 1씩 더해줘 행이 달라지기에 검사할 필요가 없다.

```c++
if (is_valid) {
    pos_v.push_back({line, column});
    f(line + 1);
    pos_v.pop_back();
}
```
벡터 `pos_v` 저장된 위치값을 다 확인을 했는데도 공격을 받지 않아 `is_valid`값이 `false`로 변하지 않았다면(여전히 `true`라면) 벡터 `pos_v`에 `(line, column)` 위치값을 넣고, `line`에 `1`을 더해 재귀함수 `f(line+1)`을 실행한다.  
(그렇게 계속 실행하다 `is_valid`가 `false`가 된다는 재귀는 끊기게 되어 자연스럽게 백트래킹이 되고, 최종적으로 
```c++
if (line == n) {
    cnt++;
    return;
}
```
로 더해진 경우의 수를 `main`함수에서 출력한다.)