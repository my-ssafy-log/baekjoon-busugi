# 11053 가장 긴 증가하는 부분 수열

[링크](https://www.acmicpc.net/problem/11053)

## 문제해설

여러 수의 나열에서 숫자가 증가하도록 첫번째부터 숫자를 하나씩 뽑는데, 이때 가장 많이 뽑아 가장 긴 증가하는 부분 수열을 찾는 문제이다.

예를들어 `10, 20, 10, 30, 20, 50`이라는 수열이 있을 때 여기서 가장 긴 증가하는 부분 수열은 `10 20 30 50`이다.

## 코드 해설
[코드](./code.py)  
먼저 arr에는 입력받는 수열과 함께 첫번재 인자에 `0`이라는 값을 넣는데 아래 방식처럼 작동하기 위해서이다.
1. i가 0일 때

여기서 [코드](./code.py)에 8번째 줄에 `len_arr`은 `i`전까지의 수열들 중 해당 인덱스(`arr[i]`)의 값보다 작은 값의 인덱스에 해당하는 `dp`배열(코드상에선 배열 `d`)의 값을 저장하는 배열이다.  
바깥 for문(이하 for(1))에서 cur에 들어가는 첫번째 값은 3번째 줄에 보이듯이 `0`이 들어가는데, `0` 이전의 수열은 없으므로 10번째 for문(이하 for(2))은 실행이 안되고,  
14번째 줄에 `if len(len_arr) == 0`에 걸려 dp배열 `d`에는 첫번째로 0이 들어간다.  
그 이후에 나오는 수열들은 무조건 for(2)문을 한번 이상 반복하며 그 수열들은 1보다 크기에 `arr`의 첫번째 값 0보다 항상 크므로,  
`0`, 즉, `arr[0]`의 인덱스 0번째에 해당하는 배열 `d`의 요소, 값인 `0`을 `len_arr`에 추가한다.  

항상 모든 숫자들에 대해 이 `0`이라는 값은 `len_arr`에 추가되므로 14번째 줄에 첫번재 값 `0`을 제외한 모든 수열에 대해서 `if len(len_arr) == 0`은 실행이 안되고,  
그 아래에 `else: d.append(max(len_arr) + 1)` 문이 실행된다.  
그렇기에 항상 모든 숫자들에 대해서 길이 1 이상이 보장될 수 있다.  

배열 `d`에 현재 `i`번째 요소에 대한 길이를 구하는 방법은  
현재 `i`번 요소보다 작은 요소들의 인덱스에 그대로 해당하는 배열 `d`값들 중 제일 큰 값에 +1을 하여 구한다.  
그러면 배열 `d`는 항상 모든 `i`번째 요소들에 대하여 최대 길이를 유지할 수 있는 것이다.